# -*- coding: utf-8 -*-
"""n-queen using dfs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HAYj95LKz3DZ1hKwLPnL9pSUHuWfVTis
"""

class Board:

    def __init__(self, N):
        self.N = N

    def dfs(self):
        if self.N < 1:
            return []
        solutions = []
        stack = [[]]
        while stack:
            solution = stack.pop()
            if self.attack(solution):
                continue
            row = len(solution)
            if row == self.N:
                solutions.append(solution)
                continue
            for col in range(self.N):
                queen = (row, col)
                queens = solution.copy()
                queens.append(queen)
                stack.append(queens)
        return solutions


    def attack(self, queen):
        for i in range(1, len(queen)):
            for j in range(0, i):
                a, b = queen[i]
                c, d = queen[j]
                if a == c or b == d or abs(a - c) == abs(b - d):
                    return True
        return False

    def print(self, queens):
        for i in range(self.N):
            print(' ---' * self.N)
            for j in range(self.N):
                p = 'Q' if (i, j) in queens else ' '
                print('| %s ' % p, end='')
            print('|')
        print(' ---' * self.N)

N = int(input('Enter the number of queens to fit: '))
if (N<3 and N!=1):
  print('No solutions are possible')
if(N==1):
  print('| Q |')
else:
  n_queens = Board(N)
  dfs = n_queens.dfs()
  for i, solution in enumerate(dfs):
    n_queens.print(solution)